<!DOCTYPE html>
<html lang="en" dir="ltr" prefix="og: http://ogp.me/ns#" id="top-of-site">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,shrink-to-fit=no">

    <link rel="canonical" href="https://liuzihe02.github.io/posts/dft-fft/">

    <title>The Discrete Fourier Transform and Fast Fourier Transform - Liu Zihe</title>
    <meta name="description" content="We analyze 1 the theoretical properties of both the Discrete Fourier Transform (DFT) and the optimized Fast Fourier Transform (FFT), and estimate their …">
    <meta name="keywords" content="hugo, ed, hugo theme, minimal, responsive, clean">

    <meta name="author" content="Serghei Iakovlev">
    <meta name="generator" content="Hugo 0.127.0">

    
    <link crossorigin="anonymous" href="/css/stylesheet.min.ddff76a17889e714853ced93d59096be3dca89927ec0e446c2d9c6b70da094a6.css" integrity="sha256-3f92oXiJ5xSFPO2T1ZCWvj3KiZJ+wORGwtnGtw2glKY=" rel="preload stylesheet" as="style">

    <link rel="icon" href="/favicon.ico" sizes="any">
    <link rel="icon" href="/red_sinc.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    
    <link rel="manifest" type="application/manifest+json" href="/manifest.webmanifest" title="Manifest">
    <link rel="sitemap" type="application/xml" href="/sitemap.xml" title="Sitemap">
    <link rel="author" type="text/plain" href="/humans.txt" title="Humans">
<link rel="alternate" hreflang="en" href="https://liuzihe02.github.io/posts/dft-fft/">

    <meta name="theme-color" content="#ffffff">
    <script>
  MathJax = {
    tex: {
      displayMath: [
        ["\\[", "\\]"],
        ["$$", "$$"],
      ], 
      inlineMath: [
        ["$", "$"],
        ["\\(", "\\)"]  
        ], 
    },
    loader: {
      load: ["ui/safe"],
    },
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
></script>

    
    <meta property="og:title" content="The Discrete Fourier Transform and Fast Fourier Transform - Liu Zihe">
    <meta property="og:description" content="We analyze 1 the theoretical properties of both the Discrete Fourier Transform (DFT) and the optimized Fast Fourier Transform (FFT), and estimate their …">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://liuzihe02.github.io/posts/dft-fft/">
    <meta property="og:image" content="https://liuzihe02.github.io/img/red_sinc.png">
    <meta property="og:image:width" content="100">
    <meta property="og:image:height" content="100">
    <meta property="article:published_time" content="2025-03-07T17:05:08">
    <meta property="article:modified_time" content="2025-03-07T17:05:08">
    
    <meta name="twitter:title" content="The Discrete Fourier Transform and Fast Fourier Transform - Liu Zihe">
    <meta name="twitter:description" content="We analyze 1 the theoretical properties of both the Discrete Fourier Transform (DFT) and the optimized Fast Fourier Transform (FFT), and estimate their …">
    <meta name="twitter:site" content="@egreps">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://liuzihe02.github.io/img/red_sinc.png">
    

<script type="application/ld+json" id="schema-data">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://liuzihe02.github.io/posts/dft-fft/"
        },
        "url": "https://liuzihe02.github.io/posts/dft-fft/",
        "headline": "The Discrete Fourier Transform and Fast Fourier Transform - Liu Zihe",
        "description": "We analyze 1 the theoretical properties of both the Discrete Fourier Transform (DFT) and the optimized Fast Fourier Transform (FFT), and estimate their …",
        "keywords": ["hugo","ed","hugo theme","minimal","responsive","clean"],
        "datePublished": "2025-03-07T17:05:08Z",
        "dateModified": "2025-03-07T17:05:08Z",
            "author": {
                "@type": "Person",
                "name": "Serghei Iakovlev",
                "url": "https://twitter.com/egreps"
            },
        "publisher": {
            "@type": "Organization",
            "name": "Serghei Iakovlev",
            "logo": {
                "@type": "ImageObject",
                "url": "https://liuzihe02.github.io/img/red_sinc_hud2b2f992c71e0cf1b31a7194e454b3b4_2840_96x96_resize_box_3.png",
                "width": "96",
                "height": "96"
            }
        }
    }
</script>



    <script src="/js/common.js"></script>
</head>

    <body class="theme-base-">
        <div id="top-of-site-anchor"></div>
        
            
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">


<aside class="sidebar" id="sidebar">
    <div class="sidebar-item">
        <p></p>
    </div>

    <nav class="sidebar-nav">
            <a class="sidebar-nav-item"
                href="/"
                id="menu-main-home">Home</a>
            <a class="sidebar-nav-item"
                href="/projects/"
                id="menu-main-projects">Projects</a>
            <a class="sidebar-nav-item active"
                href="/posts/"
                id="menu-main-posts">Posts</a>
            <a class="sidebar-nav-item"
                href="/documentation/"
                id="menu-main-documentation">Documentation</a>
            <a class="sidebar-nav-item"
                href="/poems/"
                id="menu-main-poems">Poems</a>
            <a class="sidebar-nav-item"
                href="https://drive.google.com/drive/folders/1-LHa9BiT_OILTLwLgVtdNiAymSpbTTRt?usp=sharing"
                id="menu-main-resume" target="_blank" rel="noopener noreferrer">Resume</a>
        
        
        
    </nav>

    
    <div class="sidebar-item">
        <p>Built with <a href="https://github.com/sergeyklay/gohugo-theme-ed" target="_blank" rel="noopener noreferrer">Ed</a>. Distributed under an MIT license.</p>
    </div>


</aside>
        
        <div class="wrap">
            <header class="masthead">
                <div class="container">
                    <h3 class="masthead-title">
                        <a href="/" title="Home">Liu Zihe</a>
                        <br><small>Dancing in the Moonlight</small>
                    </h3>
                </div>
            </header>

            <main class="container content" id="main">
                <article class="post" role="document">
    <header>
        <h1 class="text-title">
            The Discrete Fourier Transform and Fast Fourier Transform
        </h1>
        <p class="byline">
            
                


Published on
<time datetime="2025-03-07T17:05:08Z">
    March 7, 2025
</time>




            
        </p>
    </header>

    <div class="post-body">
        <p>We analyze <a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> the theoretical properties of both
the <em>Discrete Fourier Transform</em> (DFT) and the optimized <em>Fast
Fourier Transform</em> (FFT), and estimate their algorithmic
complexity.</p>
<hr />
<h1 id="discrete-fourier-transform">Discrete Fourier Transform</h1>
<h2 id="theory">Theory</h2>
<p>The DFT converts a finite-length time-domain signal into its
frequency-domain representation. For an input signal <span
class="math inline">\(x[n]\)</span> of length <span
class="math inline">\(N\)</span>, where <span class="math inline">\(0
\le n \le N-1\)</span>, the DFT is defined as:</p>
<p><span class="math display">\[
X[k] = \sum_{n=0}^{N-1} x[n]\, W_N^{kn}, \quad 0 \le k \le N-1
\label{eq:DFT}
\]</span></p>
<p>where <span class="math inline">\(W_N=e^{-j\frac{2\pi}{N}}\)</span>
is the <span class="math inline">\(N\)</span>-th principal root of
unity, and <span class="math inline">\(X[k]\)</span> is component at
frequency <span class="math inline">\(kf_s/N\)</span> with sampling
frequency <span class="math inline">\(f_s\)</span>. We can rewrite <span
class="math inline">\(X[k]\)</span> as an inner product:</p>
<p><span class="math display">\[
\begin{align}
X[k] &amp;= \left[ 1 \quad e^{-j\frac{2\pi k}{N}} \quad \ldots \quad
e^{-j\frac{2\pi k}{N}(N-1)} \right]
    \begin{bmatrix}
    x[0] \\
    x[1] \\
    \vdots \\
    x[N-1]
    \end{bmatrix} \\
&amp;= \left[ 1 \quad W_N^k \quad \ldots \quad W_N^{(N-1)k} \right]
    \begin{bmatrix}
    x[0] \\
    x[1] \\
    \vdots \\
    x[N-1]
    \end{bmatrix}
\end{align}
\]</span></p>
<p>By varying <span class="math inline">\(k\)</span> from <span
class="math inline">\(0\)</span> to <span
class="math inline">\(N-1\)</span>, we can collate all outputs <span
class="math inline">\({X[k]}\)</span> into a vector <span
class="math inline">\(\mathbf{X}\)</span>, collate all inputs <span
class="math inline">\(x[n]\)</span> into a vector <span
class="math inline">\(\mathbf{x}\)</span>, to get:</p>
<p><span class="math display">\[
\mathbf{X}=\mathbf{W}\mathbf{x}, \quad
\mathbf{W} =
\begin{bmatrix}
1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; W_N &amp; W_N^2 &amp; \cdots &amp; W_N^{N-1} \\
1 &amp; W_N^2 &amp; W_N^4 &amp; \cdots &amp; W_N^{2(N-1)} \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; W_N^{N-1} &amp; W_N^{2(N-1)} &amp; \cdots &amp; W_N^{(N-1)(N-1)}
\end{bmatrix}
\]</span></p>
<p>where <span class="math inline">\(\mathbf{W}\)</span> is the DFT
matrix.</p>
<h2 id="complexity">Complexity</h2>

<div style="display: block; width: 100%; margin-top: 15px; margin-bottom: 15px;">
  <img src="/figures/DFT-pseudo.png"  width="500"  
  style="display: block; margin: 0 auto;">
  
  
    <figcaption style="text-align: center; margin-top: 8px; margin-bottom: 8px; font-style: italic;">Pseudocode for DFT</figcaption>
  
</div>

<p>Direct implementation in <code>MATLAB</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="k">function</span><span class="w"> </span>X <span class="p">=</span><span class="w"> </span><span class="nf">dft_loop</span><span class="p">(</span>x<span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c">% Compute the Discrete Fourier Transform (DFT) of input vector x using naive loops</span>
</span></span><span class="line"><span class="cl"><span class="c">% x : input signal (vector)</span>
</span></span><span class="line"><span class="cl"><span class="c">% X : DFT of x</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">% Convert input to a column vector for consistency</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="p">=</span> <span class="n">x</span><span class="p">(:);</span>
</span></span><span class="line"><span class="cl">    <span class="n">N</span> <span class="p">=</span> <span class="nb">length</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>       <span class="c">% Number of samples in the signal</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">% Pre-allocate the output vector for efficiency</span>
</span></span><span class="line"><span class="cl">    <span class="n">X</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">% Loop over each frequency bin k (from 0 to N-1)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">k</span> <span class="p">=</span> <span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="n">sum_val</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c">% Loop over each time sample n (from 0 to N-1)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">n</span> <span class="p">=</span> <span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="c">% Compute and accumulate the contribution for the k-th frequency component</span>
</span></span><span class="line"><span class="cl">            <span class="n">sum_val</span> <span class="p">=</span> <span class="n">sum_val</span> <span class="o">+</span> <span class="n">x</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="nb">j</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">pi</span> <span class="o">*</span> <span class="n">k</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">N</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">end</span>
</span></span><span class="line"><span class="cl">        <span class="c">% MATLAB uses one-based indexing, so assign to X(k+1)</span>
</span></span><span class="line"><span class="cl">        <span class="n">X</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">sum_val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">end</span></span></span></code></pre></div>
<p><code>MATLAB</code> code (vectorized):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="k">function</span><span class="w"> </span>X <span class="p">=</span><span class="w"> </span><span class="nf">dft_vectorized</span><span class="p">(</span>x<span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c">% Compute the Discrete Fourier Transform (DFT) of input vector x using vectorized operations</span>
</span></span><span class="line"><span class="cl"><span class="c">% x : input signal (vector)</span>
</span></span><span class="line"><span class="cl"><span class="c">% X : DFT of x</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">% Convert input to a column vector for consistency</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="p">=</span> <span class="n">x</span><span class="p">(:);</span>
</span></span><span class="line"><span class="cl">    <span class="n">N</span> <span class="p">=</span> <span class="nb">length</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>       <span class="c">% Number of samples in the signal</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">% Create index vectors: n as a row vector and k as a column vector</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span> <span class="p">=</span> <span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>           <span class="c">% Time indices (row vector)</span>
</span></span><span class="line"><span class="cl">    <span class="n">k</span> <span class="p">=</span> <span class="n">n</span><span class="o">&#39;</span><span class="p">;</span>              <span class="c">% Frequency indices (column vector)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">% Construct the DFT matrix using the formula: exp(-1j*2*pi*k*n/N)</span>
</span></span><span class="line"><span class="cl">    <span class="n">W</span> <span class="p">=</span> <span class="nb">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="nb">j</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">pi</span> <span class="o">*</span> <span class="n">k</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">N</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">% Multiply the DFT matrix with the signal to obtain the transform</span>
</span></span><span class="line"><span class="cl">    <span class="n">X</span> <span class="p">=</span> <span class="n">W</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">end</span></span></span></code></pre></div>
<p>Direct computation of <span class="math inline">\(\mathbf{X}\)</span>
requires <span class="math inline">\((N-1)^2\)</span> complex
multiplications and <span class="math inline">\(N(N-1)\)</span> complex
additions. Since multiplication is more compute-intensive than addition,
the asymptotic complexity is dominated by multiplication, giving <span
class="math inline">\(O(N^2)\)</span>.</p>
<hr />
<h1 id="fast-fourier-transform">Fast Fourier Transform</h1>
<h2 id="theory-1">Theory</h2>
<p>The radix-2 FFT algorithms work by dividing the DFT into 2 DFTs of
length <span class="math inline">\(N/2\)</span> each, and iterating. We
introduce the simplest variant, called the <em>Decimation-In-Time</em>
(DIT) algorithm. DIT begins by splitting <span
class="math inline">\(x[n]\)</span> into two parts — one for the
even-indexed values <span class="math inline">\(x[2n]\)</span> and one
for the odd-indexed values <span class="math inline">\(x[2n +
1]\)</span>. Define two <span class="math inline">\(N/2\)</span>-point
signals <span class="math inline">\(x_{even}[n]\)</span> and <span
class="math inline">\(x_{odd}[n]\)</span> as <span
class="math display">\[x_{even}[n] = x[2n], \quad x_{odd}[n] = x[2n +
1], \quad 0 \leq n \leq N/2-1\]</span></p>
<p>using the DFT of these 2 splits gives us:</p>
<p><span class="math display">\[
\begin{aligned}
X[k] &amp;= X_{even}[k] + W_N^{k} \cdot X_{odd}[k] \quad \text{for } 0
\leq k \leq \frac{N}{2} - 1 \\
X[k + N/2] &amp;= X_{even}[k] - W_N^{k} \cdot X_{odd}[k] \quad \text{for
} 0 \leq k \leq \frac{N}{2} - 1
\label{eq:fft_final}
\end{aligned}
\]</span></p>
<p>The first computation with <span
class="math inline">\(+W_N^k\)</span> give us the first half of the full
DFT vector <span class="math inline">\(\mathbf{X}\)</span>, while the
second computation with <span class="math inline">\(-W_N^k\)</span> give
us the second half of <span class="math inline">\(\mathbf{X}\)</span>.
The proof is laid out in the Appendix.</p>
<h2 id="complexity-1">Complexity</h2>
<div class="algorithm">
<div class="algorithmic">
<p><span class="math inline">\(N \gets
\text{length}(\mathbf{x})\)</span></p>
<p><span class="math inline">\(\mathbf{x}\)</span></p>
<p><span class="math inline">\(\mathbf{x}_{even} \gets
\mathbf{x}[0:2:N-1]\)</span> <span
class="math inline">\(\mathbf{x}_{odd} \gets
\mathbf{x}[1:2:N-1]\)</span></p>
<p><span class="math inline">\(\mathbf{X}_{even} \gets
\text{FFT}(\mathbf{x}_{even})\)</span> <span
class="math inline">\(\mathbf{X}_{odd} \gets
\text{FFT}(\mathbf{x}_{odd})\)</span></p>
<p><span class="math inline">\(\mathbf{X} \gets
\text{zeros}(N)\)</span></p>
<p><span class="math inline">\(W_N^k \gets e^{-j2\pi k/N}\)</span> <span
class="math inline">\(\mathbf{X}[k] \gets \mathbf{X}_{even}[k] + W_N^k
\cdot \mathbf{X}_{odd}[k]\)</span> <span
class="math inline">\(\mathbf{X}[k+N/2] \gets \mathbf{X}_{even}[k] -
W_N^k \cdot \mathbf{X}_{odd}[k]\)</span></p>
<p><span class="math inline">\(\mathbf{X}\)</span></p>
</div>
</div>
<p>We can follow the above procedure to split an <span
class="math inline">\(N\)</span>-point DFT into two <span
class="math inline">\(\frac{N}{2}\)</span>-point DFT, giving us
Algorithm <a href="#alg:fft" data-reference-type="ref+label"
data-reference="alg:fft">[alg:fft]</a>. Let <span
class="math inline">\(A_c(N)\)</span> and <span
class="math inline">\(M_c(N)\)</span> denote respectively the number of
complex additions and multiplications for computing the DFT of an <span
class="math inline">\(N\)</span>-point complex sequence <span
class="math inline">\(x[n]\)</span>. Let <span
class="math inline">\(N\)</span> be a power of 2, <span
class="math inline">\(N = 2^k\)</span>. Then, we have <span
class="math display">\[A_c(N) = 2 A_c(N/2) + N \quad , \quad M_c(N) = 2
M_c(N/2) + \frac{N}{2} - 1\]</span></p>
<p>as <span class="math inline">\(N\)</span> complex additions (addition
of even and odd terms) and <span class="math inline">\(\frac{N}{2} -
1\)</span> complex multiplications (<span class="math inline">\(W_N^{k}
\cdot X_{odd}[k]\)</span>) are required to put the two <span
class="math inline">\(N/2\)</span>-point DFTs together. Note that a
2-point DFT is simply a sum and difference <span
class="math inline">\(X[0] = x[0] + x[1] , \quad X[1] = x[0] -
x[1]\)</span>. Hence, the starting conditions are <span
class="math inline">\(A_c(2) = 2\)</span> and <span
class="math inline">\(M_c(2) = 0\)</span>. Solving the recursive
equation yields <span class="math display">\[A_c(N) = N \log_2 N  \quad
, \quad M_c(N) = \frac{N}{2} \log_2 N - N + 1\]</span></p>
<p>Our overall complexity is <span class="math inline">\(O(N\log
N)\)</span>.</p>
<h1 id="experiments">Experiments</h1>
<h2 id="complexity-2">Complexity</h2>
<figure id="fig:complexity">
<img src="/figures/complex.jpg" style="width:40.0%"
alt="Execution time versus signal length N for various implementations of DFT and FFT" />
<figcaption aria-hidden="true">Execution time versus signal length <span
class="math inline">\(N\)</span> for various implementations of DFT and
FFT</figcaption>
</figure>
<div id="tab:R2">
<p>Algorithm O(N) O(N²) O(N³) O(log N) O(N log N)</p>
<hr />
<p>my-DFT 0.9208 0.9999 0.9864 0.4167 0.9417 my-FFT 0.9830 0.9657 0.9161
0.5634 0.9894 MATLAB-FFT 0.8491 0.7141 0.6526 0.8537 0.8287</p>
<p>: R<sup>2</sup> values for different complexity models.</p>
</div>
<p>To verify the theoretical complexity, we measured the execution time
for computing the DFT over a range of signal lengths. For each signal
length <span class="math inline">\(N\)</span>, <span
class="math inline">\(N\)</span> samples were taken from a 5Hz sine
wave, and the DFT/FFT computation time recorded. We compare our
implementation of Algorithm <a href="#alg:dft"
data-reference-type="ref+label" data-reference="alg:dft">[alg:dft]</a>
as <code>my-DFT</code>, our implementation of Algorithm <a
href="#alg:fft" data-reference-type="ref+label"
data-reference="alg:fft">[alg:fft]</a> as <code>my-FFT</code>, and the
<code>MATLAB</code> FFT implementation as <code>MATLAB-FFT</code>. <a
href="#fig:complexity" data-reference-type="ref+label"
data-reference="fig:complexity">1</a> shows the measured execution times
on a log-log plot. The FFT results clearly exhibit an <span
class="math inline">\(O(N\log N)\)</span> scaling, while the DFT scales
as <span class="math inline">\(O(N^2)\)</span>. These experimental
results confirm the significant computational advantage of using the FFT
for large-scale problems. We also note the much more efficient
implementation of <code>MATLAB</code> FFT, which uses the
<code>FFTW</code> <a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a> package. <a href="#tab:R2"
data-reference-type="ref+label" data-reference="tab:R2">1</a> show the
how well different models fit to data. Both FFT implementations fit well
to <span class="math inline">\(O(N)\)</span> and <span
class="math inline">\(O(N\log N)\)</span> models.</p>
<h2 id="numerical-error">Numerical Error</h2>
<figure id="fig:recon">
<img src="/figures/recon.jpg" style="width:40.0%"
alt="Reconstruction error versus signal length N for various implementations of DFT and FFT" />
<figcaption aria-hidden="true">Reconstruction error versus signal length
<span class="math inline">\(N\)</span> for various implementations of
DFT and FFT</figcaption>
</figure>
<p>We evaluate numerical accuracy of both algorithms in <a
href="#fig:recon" data-reference-type="ref+label"
data-reference="fig:recon">2</a> by measuring reconstruction error of
the reconstructed signal <span class="math inline">\(\text{RMSE} =
\sqrt{\frac{1}{N}\sum_{i=1}^{N}|x_i - \hat{x}_i|^2}\)</span> where <span
class="math inline">\(x_i\)</span> is the original signal and <span
class="math inline">\(\hat{x}_i\)</span> is the reconstructed signal
(using the <code>MATLAB</code> Inverse DFT function) Despite all errors
falling within the <span class="math inline">\(10^{-12}\)</span> range,
indicating high overall accuracy, the custom DFT implementation exhibits
exponentially growing error with increasing sequence length. In
contrast, both FFT implementations maintain consistently minimal error
across all tested sequence lengths. The superior numerical stability of
FFT algorithms is possibly due to its lower operation count (lower
algorithmic complexity). Floating-point rounding errors accumulate more
significantly in DFT.</p>
<h1 id="conclusion">Conclusion</h1>
<p>In this report, we investigated both theoretical and practical
aspects of the DFT and the FFT. The analysis verified that the
computational complexity of the direct DFT implementation scales as
<span class="math inline">\(O(N^2)\)</span>, whereas our FFT
implementation achieved the expected <span class="math inline">\(O(N
\log N)\)</span> complexity, offering a significant improvement in
efficiency. Moreover, the FFT exhibited superior numerical stability.
Selecting the appropriate windowing function is also crucial for
accurate frequency analysis, with the Han or Hamming window recommended
for most applications. All code available at <a
href="https://github.com/liuzihe02/dft-fft.git"
class="uri">https://github.com/liuzihe02/dft-fft.git</a>.</p>
<h1 class="unnumbered" id="app:fft_proof">Appendix: Derivation of
FFT</h1>
<p>Consider again a <span class="math inline">\(N\)</span>-point signal
<span class="math inline">\(x[n]\)</span> of even length. The derivation
of the DIT radix-2 FFT begins by splitting the <span
class="math inline">\(x[n]\)</span> into two parts — one part for the
even-indexed values <span class="math inline">\(x[2n]\)</span> and one
part for the odd-indexed values <span class="math inline">\(x[2n +
1]\)</span>. Define two <span class="math inline">\(N/2\)</span>-point
signals <span class="math inline">\(x_{even}[n]\)</span> and <span
class="math inline">\(x_{odd}[n]\)</span> as <span
class="math display">\[x_{even}[n] = x[2n], \quad x_{odd}[n] = x[2n +
1], \quad 0 \leq n \leq N/2-1\]</span></p>
<p>The DFT can be written as</p>
<p><span class="math display">\[
\begin{aligned}
X[k] &amp;= \sum_{n=0 \atop n \text{ even}}^{N-1} x[n] W_N^{nk} +
\sum_{n=0 \atop n \text{ odd}}^{N-1} x[n] W_N^{nk}\\
&amp;= \sum_{n=0}^{N/2-1} x[2n] W_N^{2nk} + \sum_{n=0}^{N/2-1} x[2n + 1]
W_N^{(2n+1)k}\\
&amp;= \sum_{n=0}^{N/2-1} x_{even}[n] W_N^{2nk} + \sum_{n=0}^{N/2-1}
x_{odd}[n] W_N^{(2n+1)k} \\
&amp;= \sum_{n=0}^{N/2-1} x_{even}[n] W_N^{2nk} + W_N^{k} \cdot
\sum_{n=0}^{N/2-1} x_{odd}[n] W_N^{2nk}\\
\end{aligned}
\]</span></p>
<p>Noting that <span class="math inline">\(W_N^{2}=W_{N/2}\)</span> or
more generally <span
class="math inline">\(W_N^{2nk}=W_{N/2}^{nk}\)</span>, <span
class="math display">\[\begin{aligned}
X[k]&amp;= \sum_{n=0}^{N/2-1} x_{even}[n] W_{N/2}^{nk} + W_N^{k} \cdot
\sum_{n=0}^{N/2-1} x_{odd}[n] W_{N/2}^{nk}
\end{aligned}\]</span></p>
<p>Recognizing that the <span
class="math inline">\(\frac{N}{2}\)</span>-point DFT of <span
class="math inline">\(x_{even}[n]\)</span> and <span
class="math inline">\(x_{odd}[n]\)</span> are given by:</p>
<p><span class="math display">\[X_{even}[k] =
\text{DFT}_{\frac{N}{2}}\{x_{even}[n]\} = \sum_{n=0}^{N/2-1} x_{even}[n]
W_{N/2}^{nk} \quad , \quad X_{odd}[k] =
\text{DFT}_{\frac{N}{2}}\{x_{odd}[n]\} = \sum_{n=0}^{N/2-1} x_{odd}[n]
W_{N/2}^{nk}\]</span></p>
<p>we then obtain our core recursive equation:</p>
<p><span class="math display">\[
X[k] = X_{even}[k] + W_N^{k} \cdot X_{odd}[k]
    \label{eq:fft_int}
\]</span></p>
<p>Since <span class="math inline">\(x_{even}[n]\)</span> and <span
class="math inline">\(x_{odd}[n]\)</span> are <span
class="math inline">\(N/2\)</span>-point signals with <span
class="math inline">\(0 \leq n \leq N/2-1\)</span>, their DFT are also
only <span class="math inline">\(N/2\)</span>-point signals. However, we
require <span class="math inline">\(0 \le k \le N-1\)</span>. We resolve
this by noting their DFT coefficients are periodic with a period of
<span class="math inline">\(\frac{N}{2}\)</span></p>
<p><span class="math display">\[X_{even}[k] = X_{even}\left[k +
\frac{N}{2}\right], \quad X_{odd}[k] = X_{odd}\left[k +
\frac{N}{2}\right]\]</span></p>
<p>This gives us</p>
<p><span class="math display">\[
X[k] =
    \begin{cases}
    X_{even}[k] + W_N^{k} \cdot X_{odd}[k], &amp; \text{for } k =
0,1,\ldots,\frac{N}{2}-1 \\
    X_{even}\left[k-\frac{N}{2}\right] + W_N^{k} \cdot
X_{odd}\left[k-\frac{N}{2}\right], &amp; \text{for } k =
\frac{N}{2},\frac{N}{2}+1,\ldots,N-1
\end{cases}
\]</span></p>
<p>Noting <span class="math inline">\(W_N^{k
+\frac{N}{2}}=-W_{N}^{k}\)</span>, we write</p>
<p><span class="math display">\[
X[k] =
    \begin{cases}
    X_{even}[k] + W_N^{k} \cdot X_{odd}[k], &amp; \text{for } k =
0,1,\ldots,\frac{N}{2}-1 \\
    X_{even}\left[k-\frac{N}{2}\right] - W_N^{k-\frac{N}{2}} \cdot
X_{odd}\left[k-\frac{N}{2}\right], &amp; \text{for } k =
\frac{N}{2},\frac{N}{2}+1,\ldots,N-1
\end{cases}
\]</span></p>
<p>finally giving us <a href="#eq:fft_final"
data-reference-type="ref+label"
data-reference="eq:fft*final">[eq:fft_final]</a>. The multipliers <span
class="math inline">\(W_N^k\)</span> are known as _twiddle factors*. The
first computation with <span class="math inline">\(+W_N^k\)</span> give
us the first half of the full DFT vector <span
class="math inline">\(\mathbf{X}\)</span>, while the second computation
with <span class="math inline">\(-W_N^k\)</span> give us the second half
of <span class="math inline">\(\mathbf{X}\)</span>.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>This post was created for educational purposes, so much
of the analysis is taken directly from the sources quoted in the
references<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>This package is highly optimized to each machine and is
written inlow level C<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

    </div>

    
    
        

<div class="tags-wrapper">
    <ul class="post-tags">
        
    </ul>
</div>

    

    
</article>

            </main>
        </div>

        <label for="sidebar-checkbox" class="sidebar-toggle"></label>

        <a href="#top-of-site" class="top-of-site-link" data-visible="false">
            <span class="screen-reader-text" aria-label="Back to top of the page">
                Back to top
            </span>
            <svg width="32" height="32" viewBox="0 0 100 100">
                <path fill="white" d="m50 0c-13.262 0-25.98 5.2695-35.355 14.645s-14.645 22.094-14.645 35.355 5.2695 25.98 14.645 35.355 22.094 14.645 35.355 14.645 25.98-5.2695 35.355-14.645 14.645-22.094 14.645-35.355-5.2695-25.98-14.645-35.355-22.094-14.645-35.355-14.645zm20.832 62.5-20.832-22.457-20.625 22.457c-1.207 0.74219-2.7656 0.57812-3.7891-0.39844-1.0273-0.98047-1.2695-2.5273-0.58594-3.7695l22.918-25c0.60156-0.61328 1.4297-0.96094 2.2891-0.96094 0.86328 0 1.6914 0.34766 2.293 0.96094l22.918 25c0.88672 1.2891 0.6875 3.0352-0.47266 4.0898-1.1562 1.0508-2.9141 1.0859-4.1133 0.078125z"></path>
            </svg>
        </a>
    </body>
</html>
